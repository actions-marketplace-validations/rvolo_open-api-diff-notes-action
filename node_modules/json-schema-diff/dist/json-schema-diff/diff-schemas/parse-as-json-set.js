"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const create_json_set_1 = require("./set-factories/create-json-set");
const keyword_defaults_1 = require("./set/keyword-defaults");
const parseSchemaProperties = (schemaProperties = {}) => {
    const objectSetProperties = {};
    for (const propertyName of Object.keys(schemaProperties)) {
        const propertySchema = schemaProperties[propertyName];
        objectSetProperties[propertyName] = parseSchemaOrUndefinedAsJsonSet(propertySchema);
    }
    return objectSetProperties;
};
const parseType = (type) => {
    if (!type) {
        return keyword_defaults_1.defaultTypes;
    }
    if (typeof type === 'string') {
        return [type];
    }
    return type;
};
const parseRequiredKeyword = (required) => required || keyword_defaults_1.defaultRequired;
const parseNumericKeyword = (keywordValue, defaultValue) => typeof keywordValue === 'number' ? keywordValue : defaultValue;
const parseTypeKeywords = (schema) => create_json_set_1.createJsonSetFromParsedSchemaKeywords({
    additionalProperties: parseSchemaOrUndefinedAsJsonSet(schema.additionalProperties),
    items: parseSchemaOrUndefinedAsJsonSet(schema.items),
    maxItems: parseNumericKeyword(schema.maxItems, keyword_defaults_1.defaultMaxItems),
    maxLength: parseNumericKeyword(schema.maxLength, keyword_defaults_1.defaultMaxLength),
    maxProperties: parseNumericKeyword(schema.maxProperties, keyword_defaults_1.defaultMaxProperties),
    minItems: parseNumericKeyword(schema.minItems, keyword_defaults_1.defaultMinItems),
    minLength: parseNumericKeyword(schema.minLength, keyword_defaults_1.defaultMinLength),
    minProperties: parseNumericKeyword(schema.minProperties, keyword_defaults_1.defaultMinProperties),
    properties: parseSchemaProperties(schema.properties),
    required: parseRequiredKeyword(schema.required),
    type: parseType(schema.type)
});
const parseAllOfKeyword = (allOfSchemas) => (allOfSchemas || []).map(parseSchemaOrUndefinedAsJsonSet);
const parseAnyOfKeyword = (anyOfSchemas) => {
    if (!anyOfSchemas) {
        return [];
    }
    const parsedAnyOfSet = anyOfSchemas
        .map(parseSchemaOrUndefinedAsJsonSet)
        .reduce((accumulator, set) => accumulator.union(set));
    return [parsedAnyOfSet];
};
const parseNotKeyword = (notSchema) => {
    if (!notSchema) {
        return [];
    }
    return [parseSchemaOrUndefinedAsJsonSet(notSchema).complement()];
};
const parseOneOfKeyword = (oneOfSchemas) => {
    if (!oneOfSchemas) {
        return [];
    }
    // oneOf: [A, B, C] = (A && !B && !C) || (!A && B && !C) || (!A && !B && C)
    const parsedSchemaList = oneOfSchemas.map(parseSchemaOrUndefinedAsJsonSet);
    const complementedSchemas = parsedSchemaList.map((schema) => schema.complement());
    const parsedOneOfSchema = parsedSchemaList
        .map((schema, i) => [...complementedSchemas.slice(0, i), schema, ...complementedSchemas.slice(i + 1)])
        .map((schemaGroup) => schemaGroup.reduce((acc, schema) => acc.intersect(schema)))
        .reduce((acc, schemaGroup) => acc.union(schemaGroup));
    return [parsedOneOfSchema];
};
const parseBooleanLogicKeywords = (schema) => [
    ...parseAnyOfKeyword(schema.anyOf),
    ...parseAllOfKeyword(schema.allOf),
    ...parseNotKeyword(schema.not),
    ...parseOneOfKeyword(schema.oneOf)
];
const parseCoreSchemaMetaSchema = (schema) => {
    const typeKeywordsSet = parseTypeKeywords(schema);
    const booleanLogicKeywordSets = parseBooleanLogicKeywords(schema);
    return booleanLogicKeywordSets.reduce((accumulator, set) => accumulator.intersect(set), typeKeywordsSet);
};
const parseBooleanSchema = (schema) => {
    const allowsAllJsonValues = schema === undefined ? true : schema;
    return allowsAllJsonValues ? create_json_set_1.createAllJsonSet() : create_json_set_1.createEmptyJsonSet();
};
const parseSchemaOrUndefinedAsJsonSet = (schema) => {
    return (typeof schema === 'boolean' || schema === undefined)
        ? parseBooleanSchema(schema)
        : parseCoreSchemaMetaSchema(schema);
};
exports.parseAsJsonSet = (schema) => {
    return parseSchemaOrUndefinedAsJsonSet(schema);
};
