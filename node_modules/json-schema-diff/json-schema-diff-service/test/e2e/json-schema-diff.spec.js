'use strict';

const makeRequest = require('./support/make-request');
const startServer = require('./support/start-server');
const waitForCondition = require('./support/wait-for-condition');
const _ = require('lodash');

describe('json-schema-diff', () => {
    let server;

    const expectNoServerErrors = () => {
        const errors = server.getErrors();

        expect(errors.length).toBe(0, 'expect no server errors');
        errors.forEach((error) => expect(error).toBeUndefined());
    };

    beforeAll(async () => {
        server = await startServer(8080);
        await waitForCondition(server.isReady, 5000);
    });

    afterAll(() => {
        server.stop();
    });

    beforeEach(() => {
        expectNoServerErrors();
        server.clearLogLines();
    });

    const createSchemaWithNDefinitions = (n) => {
        const schemaWithNDefinitions = {
            definitions: {},
            type: 'object'
        };

        for (let i = 0; i < n; i += 1) {
            schemaWithNDefinitions.definitions[`definition${i}`] = {type: 'string'}
        }

        return schemaWithNDefinitions
    };

    const requestHasBeenLogged = (requestId) => server.getLogLines()
        .some((line) => line.code === 'http.respond' && line.request.url.indexOf(requestId) > -1);

    const makeRequestAndWaitForLogs = async (options) => {
        const requestId = _.uniqueId();

        options.url = options.url + `?requestId=${requestId}`;

        const response = await makeRequest(options);
        await waitForCondition(() => requestHasBeenLogged(requestId), 1000);
        return response;
    };

    describe('GET /healthcheck', () => {
        const makeHealthcheckRequest = () => makeRequestAndWaitForLogs({url: '/healthcheck'});

        it('should return the service version', async () => {
            const responseAndBody = await makeHealthcheckRequest();

            expect(responseAndBody.body.version).toEqual(jasmine.any(String))
        });

        it('should log the http request and response', async () => {
            await makeHealthcheckRequest();

            expect(server.getLogLines()).toContain(jasmine.objectContaining({
                code: 'http.respond',
                msg: jasmine.stringMatching('GET /healthcheck'),
                request: {
                    method: 'GET',
                    url: jasmine.stringMatching('/healthcheck')
                },
                response: {statusCode: 200}
            }));
        });
    });

    describe('POST /diffSchemas', () => {
        const makePostDiffSchemasRequest = (options) => makeRequestAndWaitForLogs({
            body: {
                sourceSchema: options.sourceSchema,
                destinationSchema: options.destinationSchema
            },
            expectedStatusCode: options.expectedStatusCode,
            method: 'POST',
            url: '/diffSchemas'
        });

        it('should return no differences when the schemas are the same', async () => {
            const {body} = await makePostDiffSchemasRequest({sourceSchema: true, destinationSchema: true});

            expect(body).toEqual({
                additionsFound: false,
                addedJsonSchema: false,
                removalsFound: false,
                removedJsonSchema: false
            });
        });

        it('should return differences when the schemas are the different', async () => {
            const {body} = await makePostDiffSchemasRequest({
                sourceSchema: {type: 'string'},
                destinationSchema: {type: 'number'}
            });

            expect(body).toEqual({
                additionsFound: true,
                addedJsonSchema: {type: 'number'},
                removalsFound: true,
                removedJsonSchema: {type: 'string'}
            });
        });

        it('should return bad request when the input is not a schema', async () => {
            const {body} = await makePostDiffSchemasRequest({
                sourceSchema: {type: 'not-a-valid-type'},
                destinationSchema: true,
                expectedStatusCode: 400
            });

            expect(body).toEqual({error: jasmine.stringMatching('Source schema is not a valid json schema')});
        });

        it('should return bad request when the input has an unresolvable reference', async () => {
            const {body} = await makePostDiffSchemasRequest({
                sourceSchema: {$ref: '#/doesNotExist'},
                destinationSchema: true,
                expectedStatusCode: 400
            });

            expect(body).toEqual({error: jasmine.stringMatching('Error resolving \\$ref pointer')});
        });

        it('should return bad request when the input is missing sourceSchema', async () => {
            const {body} = await makePostDiffSchemasRequest({
                destinationSchema: true,
                expectedStatusCode: 400
            });

            expect(body).toEqual({error: 'Request validation failed: Parameter (body) failed schema validation'});
        });

        it('should return bad request when the input is missing sourceSchema', async () => {
            const {body} = await makePostDiffSchemasRequest({
                sourceSchema: true,
                expectedStatusCode: 400
            });

            expect(body).toEqual({error: 'Request validation failed: Parameter (body) failed schema validation'});
        });

        it('should return a difference result when a less then 5mb request body is sent', async () => {
            const largeSchema = createSchemaWithNDefinitions(70000);

            await makePostDiffSchemasRequest({
                sourceSchema: largeSchema,
                destinationSchema: largeSchema
            });
        });

        it('should return a difference result when a greater then 5mb request body is sent', async () => {
            const largeSchema = createSchemaWithNDefinitions(80000);

            const {body} = await makePostDiffSchemasRequest({
                expectedStatusCode: 413,
                sourceSchema: largeSchema,
                destinationSchema: largeSchema
            });

            expect(body).toEqual({error: 'request entity too large'});
        });

        it('should return bad request when the input has an circular reference', async () => {
            const {body} = await makePostDiffSchemasRequest({
                sourceSchema: {
                    definitions: {
                        name: {
                            $ref: '#/definitions/name'
                        }
                    },
                    properties: {
                        name: {
                            $ref: '#/definitions/name'
                        }
                    },
                    type: 'object'
                },
                destinationSchema: true,
                expectedStatusCode: 400
            });

            expect(body).toEqual({error: jasmine.stringMatching('Circular \\$ref pointer found')});
        });

        it('should log the http request and response', async () => {
            await makePostDiffSchemasRequest({sourceSchema: true, destinationSchema: true});

            expect(server.getLogLines()).toContain(jasmine.objectContaining({
                code: 'http.respond',
                msg: jasmine.stringMatching('POST /diffSchemas'),
                request: {
                    method: 'POST',
                    url: jasmine.stringMatching('/diffSchemas')
                },
                response: {statusCode: 200}
            }));
        });
    });
});
